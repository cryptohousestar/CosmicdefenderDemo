<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Defender - Mercurio</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .planet-container {
            position: relative;
            width: 100%;
            height: 100vh;
            background: linear-gradient(135deg, #888888 0%, #666666 50%, #888888 100%);
            overflow: hidden;
        }
        
        .planet-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .planet-stats {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #888888;
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-family: 'Courier New', monospace;
            pointer-events: auto;
        }
        
        .planet-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #888888;
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-family: 'Courier New', monospace;
            pointer-events: auto;
            text-align: right;
        }
        
        .wave-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #888888;
            border-radius: 15px;
            padding: 20px;
            color: white;
            text-align: center;
            display: none;
        }
        
        .wave-number {
            font-size: 48px;
            font-weight: bold;
            color: #888888;
            margin-bottom: 10px;
        }
        
        .wave-enemies {
            font-size: 24px;
            margin-bottom: 20px;
        }
        
        .wave-progress {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px auto;
        }
        
        .wave-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #888888, #aaaaaa);
            transition: width 0.3s ease;
        }
        
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #888888;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            pointer-events: auto;
        }
        
        .back-button:hover {
            background: rgba(136, 136, 136, 0.2);
        }
        
        .planet-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, #888888 0%, #666666 100%);
        }
        
        .mercury-craters {
            position: absolute;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 30% 40%, rgba(100, 100, 100, 0.3) 0%, transparent 40%),
                radial-gradient(circle at 70% 60%, rgba(80, 80, 80, 0.2) 0%, transparent 35%),
                radial-gradient(circle at 20% 80%, rgba(120, 120, 120, 0.1) 0%, transparent 30%);
        }
        
        .player-join-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 0, 0.9);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 15px;
            color: white;
            text-align: center;
            display: none;
            z-index: 100;
        }
        
        .player-leave-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            border: 2px solid #ff0000;
            border-radius: 10px;
            padding: 15px;
            color: white;
            text-align: center;
            display: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="planet-container">
        <div class="planet-background">
            <div class="mercury-craters"></div>
        </div>
        
        <div class="planet-ui">
            <div class="planet-stats">
                <div>Nivel: <span id="planet-level">1</span></div>
                <div>HP: <span id="planet-hp">100/100</span></div>
                <div>EXP: <span id="planet-exp">0/100</span></div>
                <div>Puntos: <span id="planet-score">0</span></div>
                <div>Monedas: <span id="planet-coins">0</span></div>
                <div>Enemigos: <span id="planet-enemies">0</span></div>
                <div>Jugadores: <span id="players-count">1/5</span></div>
                <div>Bots IA: <span id="bots-count">4</span></div>
                <div>Estado: <span id="ai-status">üü¢ IA Activa</span></div>
            </div>
            
            <div class="planet-info">
                <div>Planeta: <span id="current-planet">Mercurio</span></div>
                <div>Oleada: <span id="current-wave">1</span></div>
                <div>Tiempo: <span id="planet-time">00:00</span></div>
                <div>Enemigos Restantes: <span id="enemies-remaining">30</span></div>
                <div>Tu ID: <span id="player-id">1</span></div>
            </div>
            
            <button class="back-button" onclick="window.location.href='index.html'">‚Üê Volver al Mapa PvP</button>
            
            <div class="wave-info" id="waveInfo">
                <div class="wave-number" id="waveNumber">OLEADA 1</div>
                <div class="wave-enemies" id="waveEnemies">30 Enemigos</div>
                <div class="wave-progress">
                    <div class="wave-progress-fill" id="waveProgressFill"></div>
                </div>
                <div id="waveStatus">Preparando oleada...</div>
            </div>
            
            <div class="player-join-notification" id="playerJoinNotification">
                <div>¬°Nuevo jugador se uni√≥!</div>
                <div id="newPlayerName">Jugador</div>
            </div>
            
            <div class="player-leave-notification" id="playerLeaveNotification">
                <div>Un jugador se desconect√≥</div>
                <div id="leftPlayerName">Jugador</div>
            </div>
        </div>
        
        <canvas id="planetCanvas" width="1200" height="800"></canvas>
    </div>
    
    <script>
        // Mercury Dungeon Game with Multiplayer Support
        class MercuryDungeon {
            constructor() {
                this.canvas = document.getElementById('planetCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameState = 'playing';
                this.players = [];
                this.bots = [];
                this.enemies = [];
                this.bullets = [];
                this.enemyBullets = [];
                this.particles = [];
                this.coins = [];
                
                // Player stats
                this.level = 1;
                this.exp = 0;
                this.expToNext = 100;
                this.score = 0;
                this.coins = 0;
                this.health = 100;
                this.maxHealth = 100;
                
                // Wave system
                this.currentWave = 1;
                this.maxWaves = 50;
                this.enemiesInWave = 30;
                this.enemiesRemaining = 30;
                this.enemiesKilled = 0;
                this.waveStartTime = Date.now();
                this.gameStartTime = Date.now();
                
                // Controls
                this.keys = {};
                this.mouse = { x: 0, y: 0, clicked: false };
                this.lastShot = 0;
                this.fireRate = 300;
                
                // Mercury specific
                this.planetName = "Mercurio";
                this.planetColor = "#888888";
                this.gravity = 0.4;
                this.temperature = 167; // Celsius
                
                // Multiplayer
                this.maxPlayers = 5;
                this.currentPlayerId = 1;
                this.playerNames = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon'];
                this.playerColors = ['#00ff00', '#00ffff', '#ffff00', '#ff00ff', '#ff8800'];
                this.isLocalPlayer = true;
                
                // Nombres realistas para jugadores simulados
                this.realisticNames = [
                    'Alex', 'Sarah', 'Mike', 'Emma', 'David', 'Lisa', 'John', 'Maria',
                    'Chris', 'Anna', 'Tom', 'Sophie', 'Ryan', 'Laura', 'Mark', 'Julia',
                    'Steve', 'Nina', 'Paul', 'Kate', 'Dan', 'Rachel', 'Matt', 'Clara',
                    'Nick', 'Eva', 'Rob', 'Maya', 'Sam', 'Zoe', 'Tim', 'Luna',
                    'Jack', 'Iris', 'Ben', 'Rose', 'Luke', 'Dawn', 'Max', 'Star',
                    'Leo', 'Nova', 'Kai', 'Aurora', 'Zane', 'Sky', 'Jade', 'River'
                ];
                
                this.realisticColors = [
                    '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57',
                    '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43',
                    '#10ac84', '#ee5a24', '#575fcf', '#3c40c6', '#0fbcf9',
                    '#26de81', '#fed330', '#fd79a8', '#fdcb6e', '#6c5ce7'
                ];
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.createLocalPlayer();
                this.createBots();
                this.startWave();
                this.gameLoop();
                this.simulateMultiplayer();
                this.setupDemoControls();
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('click', () => {
                    this.mouse.clicked = true;
                });
            }
            
            setupDemoControls() {
                // Agregar controles de demostraci√≥n para probar el sistema
                const demoDiv = document.createElement('div');
                demoDiv.style.cssText = `
                    position: fixed;
                    top: 100px;
                    right: 20px;
                    background: rgba(0, 0, 0, 0.8);
                    border: 2px solid #00ff00;
                    border-radius: 10px;
                    padding: 15px;
                    color: white;
                    font-family: Arial, sans-serif;
                    z-index: 1000;
                    pointer-events: auto;
                `;
                
                demoDiv.innerHTML = `
                    <h4>üéÆ Demo Multijugador</h4>
                    <button onclick="window.gameDemo.addRealPlayer()" style="margin: 5px; padding: 5px 10px; background: #00ff00; border: none; border-radius: 5px; color: black; cursor: pointer;">‚ûï Agregar Jugador Real</button><br>
                    <button onclick="window.gameDemo.removeRealPlayer()" style="margin: 5px; padding: 5px 10px; background: #ff0000; border: none; border-radius: 5px; color: white; cursor: pointer;">‚ûñ Quitar Jugador Real</button><br>
                    <small>Los simulados se convierten en bots autom√°ticamente</small>
                `;
                
                document.body.appendChild(demoDiv);
                
                // Hacer el juego accesible globalmente para la demo
                window.gameDemo = this;
            }
            
            createLocalPlayer() {
                const player = {
                    id: this.currentPlayerId,
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    width: 30,
                    height: 30,
                    speed: 5,
                    health: this.health,
                    maxHealth: this.maxHealth,
                    damage: 25,
                    angle: 0,
                    name: this.playerNames[0],
                    color: this.playerColors[0],
                    isLocalPlayer: true,
                    isBot: false
                };
                this.players.push(player);
            }
            
            createBots() {
                for (let i = 1; i < this.maxPlayers; i++) {
                    const bot = {
                        id: i + 1,
                        x: 100 + i * 200,
                        y: 100,
                        width: 25,
                        height: 25,
                        speed: 4,
                        health: 80,
                        maxHealth: 80,
                        damage: 20,
                        angle: 0,
                        name: this.playerNames[i],
                        color: this.playerColors[i],
                        isLocalPlayer: false,
                        isBot: true,
                        lastShot: 0,
                        fireRate: 500,
                        target: null,
                        // AI avanzada
                        aiLevel: Math.floor(Math.random() * 3) + 1, // 1-3
                        behavior: ['aggressive', 'defensive', 'balanced'][Math.floor(Math.random() * 3)],
                        lastDirectionChange: 0,
                        directionChangeInterval: 2000 + Math.random() * 3000,
                        preferredDistance: 80 + Math.random() * 120,
                        dodgeCooldown: 0,
                        lastDodge: 0,
                        // Bonificaciones de IA
                        attackBonus: 0,
                        defenseBonus: 0,
                        speedBonus: 0,
                        accuracyBonus: 0,
                        // Estados especiales
                        isDodging: false,
                        isCharging: false,
                        chargeCooldown: 0,
                        lastCharge: 0,
                        // T√°cticas avanzadas
                        formationPosition: i,
                        lastFormationUpdate: 0,
                        tacticalMode: 'normal', // normal, flanking, retreat, charge
                        healthThreshold: 0.3 + Math.random() * 0.4 // 30-70%
                    };
                    
                    // Aplicar bonificaciones seg√∫n nivel de IA
                    this.applyAIBonuses(bot);
                    this.bots.push(bot);
                }
            }
            
            applyAIBonuses(bot) {
                switch(bot.aiLevel) {
                    case 1: // IA B√°sica
                        bot.attackBonus = 5;
                        bot.defenseBonus = 3;
                        bot.speedBonus = 2;
                        bot.accuracyBonus = 0.1;
                        break;
                    case 2: // IA Intermedia
                        bot.attackBonus = 12;
                        bot.defenseBonus = 8;
                        bot.speedBonus = 5;
                        bot.accuracyBonus = 0.2;
                        bot.damage += bot.attackBonus;
                        bot.health += bot.defenseBonus * 5;
                        bot.maxHealth += bot.defenseBonus * 5;
                        bot.speed += bot.speedBonus * 0.5;
                        break;
                    case 3: // IA Avanzada
                        bot.attackBonus = 20;
                        bot.defenseBonus = 15;
                        bot.speedBonus = 8;
                        bot.accuracyBonus = 0.3;
                        bot.damage += bot.attackBonus;
                        bot.health += bot.defenseBonus * 8;
                        bot.maxHealth += bot.defenseBonus * 8;
                        bot.speed += bot.speedBonus * 0.8;
                        bot.fireRate = Math.max(200, bot.fireRate - 100);
                        break;
                }
            }
            
            simulateMultiplayer() {
                // Simulaci√≥n SOLO cuando NO hay jugadores reales
                setInterval(() => {
                    // Solo simular si NO hay jugadores reales (solo el local)
                    const realPlayers = this.players.filter(p => !p.isSimulated);
                    if (Math.random() < 0.1 && 
                        realPlayers.length === 1 && // Solo el jugador local
                        this.bots.length > 0) {
                        this.simulatePlayerJoin();
                    }
                }, 10000);
                
                setInterval(() => {
                    // Solo desconectar jugadores simulados
                    const simulatedPlayers = this.players.filter(p => p.isSimulated);
                    if (Math.random() < 0.05 && simulatedPlayers.length > 0) {
                        this.simulatePlayerLeave();
                    }
                }, 15000);
            }
            
            simulatePlayerJoin() {
                const botIndex = Math.floor(Math.random() * this.bots.length);
                const bot = this.bots[botIndex];
                
                // Generar nombre realista para el jugador simulado
                const availableNames = this.realisticNames.filter(name => 
                    !this.players.some(p => p.name === name) && 
                    !this.bots.some(b => b.name === name)
                );
                
                const randomName = availableNames.length > 0 
                    ? availableNames[Math.floor(Math.random() * availableNames.length)]
                    : this.realisticNames[Math.floor(Math.random() * this.realisticNames.length)];
                
                const randomColor = this.realisticColors[Math.floor(Math.random() * this.realisticColors.length)];
                
                // Convertir bot a jugador simulado con nombre realista
                bot.isBot = false;
                bot.isLocalPlayer = false;
                bot.isSimulated = true;
                bot.name = randomName;
                bot.color = randomColor;
                bot.originalBotName = bot.name; // Guardar nombre original del bot
                
                this.players.push(bot);
                this.bots.splice(botIndex, 1);
                
                this.showPlayerJoinNotification(randomName);
                this.updatePlayerCounts();
            }
            
            simulatePlayerLeave() {
                // Solo desconectar jugadores simulados
                const simulatedPlayers = this.players.filter(p => !p.isLocalPlayer && p.isSimulated);
                if (simulatedPlayers.length > 0) {
                    const playerIndex = Math.floor(Math.random() * simulatedPlayers.length);
                    const player = simulatedPlayers[playerIndex];
                    
                    // Convertir jugador simulado de vuelta a bot
                    player.isBot = true;
                    player.isLocalPlayer = false;
                    player.isSimulated = false;
                    player.name = player.originalBotName || this.playerNames[player.id - 1] || 'Bot';
                    player.color = this.playerColors[player.id - 1] || '#888888';
                    this.bots.push(player);
                    
                    const playerArrayIndex = this.players.findIndex(p => p.id === player.id);
                    this.players.splice(playerArrayIndex, 1);
                    
                    this.showPlayerLeaveNotification(player.name);
                    this.updatePlayerCounts();
                }
            }
            
            // M√©todo para jugadores reales (llamado por sistema de red real)
            realPlayerJoin(playerData) {
                if (this.players.length < this.maxPlayers) {
                    // Si hay jugadores simulados, convertirlos de vuelta a bots
                    this.convertSimulatedToBots();
                    
                    const newPlayer = {
                        id: playerData.id,
                        x: playerData.x || this.canvas.width / 2,
                        y: playerData.y || this.canvas.height / 2,
                        width: 30,
                        height: 30,
                        speed: 5,
                        health: 100,
                        maxHealth: 100,
                        damage: 25,
                        angle: 0,
                        name: playerData.name,
                        color: playerData.color,
                        isLocalPlayer: false,
                        isBot: false,
                        isSimulated: false // Jugador real
                    };
                    
                    this.players.push(newPlayer);
                    this.showPlayerJoinNotification(newPlayer.name);
                    this.updatePlayerCounts();
                }
            }
            
            realPlayerLeave(playerId) {
                const playerIndex = this.players.findIndex(p => p.id === playerId && !p.isLocalPlayer);
                if (playerIndex !== -1) {
                    const player = this.players[playerIndex];
                    this.players.splice(playerIndex, 1);
                    this.showPlayerLeaveNotification(player.name);
                    this.updatePlayerCounts();
                }
            }
            
            // M√©todos para la demo
            addRealPlayer() {
                if (this.players.length < this.maxPlayers) {
                    const availableNames = this.realisticNames.filter(name => 
                        !this.players.some(p => p.name === name) &&
                        !this.bots.some(b => b.name === name)
                    );
                    
                    if (availableNames.length > 0) {
                        const randomName = availableNames[Math.floor(Math.random() * availableNames.length)];
                        const randomColor = this.realisticColors[Math.floor(Math.random() * this.realisticColors.length)];
                        
                        this.realPlayerJoin({
                            id: Date.now() + Math.random(),
                            name: randomName,
                            color: randomColor,
                            x: Math.random() * this.canvas.width,
                            y: Math.random() * this.canvas.height
                        });
                    }
                }
            }
            
            removeRealPlayer() {
                const realPlayers = this.players.filter(p => !p.isLocalPlayer && !p.isSimulated);
                if (realPlayers.length > 0) {
                    const randomPlayer = realPlayers[Math.floor(Math.random() * realPlayers.length)];
                    this.realPlayerLeave(randomPlayer.id);
                }
            }
            
            // Convertir jugadores simulados de vuelta a bots cuando llega un jugador real
            convertSimulatedToBots() {
                const simulatedPlayers = this.players.filter(p => p.isSimulated);
                simulatedPlayers.forEach(player => {
                    // Convertir de vuelta a bot
                    player.isBot = true;
                    player.isSimulated = false;
                    player.name = player.originalBotName || this.playerNames[player.id - 1] || 'Bot';
                    player.color = this.playerColors[player.id - 1] || '#888888';
                    
                    // Mover de players a bots
                    const playerIndex = this.players.findIndex(p => p.id === player.id);
                    this.players.splice(playerIndex, 1);
                    this.bots.push(player);
                    
                    this.showPlayerLeaveNotification(player.name);
                });
            }
            
            showPlayerJoinNotification(playerName) {
                const notification = document.getElementById('playerJoinNotification');
                document.getElementById('newPlayerName').textContent = playerName;
                notification.style.display = 'block';
                
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }
            
            showPlayerLeaveNotification(playerName) {
                const notification = document.getElementById('playerLeaveNotification');
                document.getElementById('leftPlayerName').textContent = playerName;
                notification.style.display = 'block';
                
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 3000);
            }
            
            updatePlayerCounts() {
                const realPlayers = this.players.filter(p => !p.isSimulated).length;
                const simulatedPlayers = this.players.filter(p => p.isSimulated).length;
                const totalPlayers = this.players.length;
                
                document.getElementById('players-count').textContent = `${totalPlayers}/${this.maxPlayers}`;
                document.getElementById('bots-count').textContent = this.bots.length;
                
                // Actualizar estado de IA (sin revelar que hay simulados)
                const aiStatusElement = document.getElementById('ai-status');
                if (realPlayers > 1 || simulatedPlayers > 0) {
                    aiStatusElement.textContent = 'üü¢ Multijugador Activo';
                    aiStatusElement.style.color = '#00ff00';
                } else {
                    aiStatusElement.textContent = 'üü¢ IA Avanzada Activa';
                    aiStatusElement.style.color = '#00ff00';
                }
                
                // Mostrar estado del sistema
                if (realPlayers > 1) {
                    console.log(`üéÆ Multijugador Real: ${realPlayers} jugadores + ${this.bots.length} bots IA`);
                } else if (simulatedPlayers > 0) {
                    console.log(`üë§ Jugadores Simulados: ${realPlayers} real + ${simulatedPlayers} simulados + ${this.bots.length} bots IA`);
                } else {
                    console.log(`ü§ñ Modo Solitario: ${realPlayers} jugador + ${this.bots.length} bots con IA Avanzada`);
                }
            }
            
            startWave() {
                this.enemiesInWave = 30 + (this.currentWave - 1) * 10;
                this.enemiesRemaining = this.enemiesInWave;
                this.enemiesKilled = 0;
                this.waveStartTime = Date.now();
                
                this.showWaveInfo();
                this.spawnEnemies();
            }
            
            showWaveInfo() {
                const waveInfo = document.getElementById('waveInfo');
                const waveNumber = document.getElementById('waveNumber');
                const waveEnemies = document.getElementById('waveEnemies');
                
                waveNumber.textContent = `OLEADA ${this.currentWave}`;
                waveEnemies.textContent = `${this.enemiesInWave} Enemigos`;
                
                waveInfo.style.display = 'block';
                
                setTimeout(() => {
                    waveInfo.style.display = 'none';
                }, 3000);
            }
            
            spawnEnemies() {
                const enemiesToSpawn = Math.min(8, this.enemiesRemaining);
                
                for (let i = 0; i < enemiesToSpawn; i++) {
                    this.spawnEnemy();
                }
            }
            
            spawnEnemy() {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                
                switch(side) {
                    case 0: x = Math.random() * this.canvas.width; y = -50; break;
                    case 1: x = this.canvas.width + 50; y = Math.random() * this.canvas.height; break;
                    case 2: x = Math.random() * this.canvas.width; y = this.canvas.height + 50; break;
                    case 3: x = -50; y = Math.random() * this.canvas.height; break;
                }
                
                const enemy = {
                    x: x,
                    y: y,
                    width: 30 + Math.random() * 20,
                    height: 30 + Math.random() * 20,
                    speed: 1.5 + Math.random() * 2,
                    health: 40 + this.currentWave * 8,
                    maxHealth: 40 + this.currentWave * 8,
                    damage: 8 + this.currentWave * 3,
                    type: 'mercury_enemy',
                    lastShot: 0,
                    fireRate: 800 + Math.random() * 800,
                    angle: 0,
                    color: '#888888'
                };
                
                this.enemies.push(enemy);
            }
            
            updatePlayers() {
                this.players.forEach(player => {
                    if (player.isLocalPlayer) {
                        this.updateLocalPlayer(player);
                    } else {
                        this.updateRemotePlayer(player);
                    }
                });
            }
            
            updateLocalPlayer(player) {
                if (this.keys['w'] || this.keys['arrowup']) {
                    player.y = Math.max(0, player.y - player.speed);
                }
                if (this.keys['s'] || this.keys['arrowdown']) {
                    player.y = Math.min(this.canvas.height - player.height, player.y + player.speed);
                }
                if (this.keys['a'] || this.keys['arrowleft']) {
                    player.x = Math.max(0, player.x - player.speed);
                }
                if (this.keys['d'] || this.keys['arrowright']) {
                    player.x = Math.min(this.canvas.width - player.width, player.x + player.speed);
                }
                
                const dx = this.mouse.x - (player.x + player.width / 2);
                const dy = this.mouse.y - (player.y + player.height / 2);
                player.angle = Math.atan2(dy, dx);
                
                if (this.mouse.clicked && Date.now() - this.lastShot > this.fireRate) {
                    this.shoot(player);
                    this.lastShot = Date.now();
                }
            }
            
            updateRemotePlayer(player) {
                if (player.isSimulated) {
                    // Comportamiento m√°s realista para jugadores simulados
                    this.updateSimulatedPlayer(player);
                } else {
                    // Comportamiento para jugadores reales remotos
                    this.updateRealRemotePlayer(player);
                }
            }
            
            updateSimulatedPlayer(player) {
                // Comportamiento completamente realista para jugadores simulados
                
                // Buscar objetivo m√°s cercano
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                
                this.enemies.forEach(enemy => {
                    const dx = enemy.x - player.x;
                    const dy = enemy.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestEnemy = enemy;
                    }
                });
                
                if (nearestEnemy) {
                    // Movimiento hacia el enemigo con variaci√≥n humana realista
                    const dx = nearestEnemy.x - player.x;
                    const dy = nearestEnemy.y - player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Variaci√≥n humana m√°s sutil y realista
                    const humanVariation = (Math.random() - 0.5) * 0.2;
                    const moveSpeed = player.speed * (0.9 + humanVariation);
                    
                    // Comportamiento t√°ctico humano
                    if (distance > 100) {
                        // Acercarse al enemigo
                        player.x += (dx / distance) * moveSpeed;
                        player.y += (dy / distance) * moveSpeed;
                    } else if (distance < 60) {
                        // Mantener distancia de seguridad
                        player.x -= (dx / distance) * moveSpeed * 0.7;
                        player.y -= (dy / distance) * moveSpeed * 0.7;
                    }
                    
                    // Actualizar √°ngulo hacia el objetivo
                    player.angle = Math.atan2(dy, dx);
                    
                    // Disparar con precisi√≥n humana realista
                    if (Date.now() - player.lastShot > player.fireRate) {
                        // Precisi√≥n humana con variaci√≥n natural
                        const humanAccuracy = 0.9 + (Math.random() - 0.5) * 0.15;
                        const accuracyOffset = (1 - humanAccuracy) * (Math.random() - 0.5) * 0.3;
                        
                        const adjustedAngle = player.angle + accuracyOffset;
                        
                        // Crear bala normal (sin indicadores especiales)
                        const bullet = {
                            x: player.x + player.width / 2 - 2,
                            y: player.y + player.height / 2 - 2,
                            width: 4,
                            height: 4,
                            speed: 8,
                            angle: adjustedAngle,
                            damage: player.damage,
                            isPlayerBullet: true,
                            playerColor: player.color
                        };
                        
                        this.bullets.push(bullet);
                        player.lastShot = Date.now();
                    }
                } else {
                    // Patrulla realista cuando no hay enemigos
                    if (!player.patrolDirection || Math.random() < 0.005) {
                        player.patrolDirection = Math.random() * Math.PI * 2;
                    }
                    
                    // Movimiento de patrulla m√°s suave
                    player.x += Math.cos(player.patrolDirection) * player.speed * 0.4;
                    player.y += Math.sin(player.patrolDirection) * player.speed * 0.4;
                }
                
                // Mantener dentro del canvas
                player.x = Math.max(0, Math.min(this.canvas.width - player.width, player.x));
                player.y = Math.max(0, Math.min(this.canvas.height - player.height, player.y));
            }
            
            updateRealRemotePlayer(player) {
                // Simular movimiento de jugador real remoto (m√°s simple)
                if (Math.random() < 0.02) {
                    const dx = (Math.random() - 0.5) * 200;
                    const dy = (Math.random() - 0.5) * 200;
                    player.x = Math.max(0, Math.min(this.canvas.width - player.width, player.x + dx));
                    player.y = Math.max(0, Math.min(this.canvas.height - player.height, player.y + dy));
                }
                
                // Simular disparo
                if (Math.random() < 0.01) {
                    this.shoot(player);
                }
            }
            
            updateBots() {
                this.bots.forEach(bot => {
                    this.updateBotAI(bot);
                });
            }
            
            updateBotAI(bot) {
                // Evaluar situaci√≥n t√°ctica
                this.evaluateTacticalSituation(bot);
                
                // Buscar objetivos
                const target = this.findBestTarget(bot);
                bot.target = target;
                
                if (target) {
                    // Calcular distancia al objetivo
                    const dx = target.x - bot.x;
                    const dy = target.y - bot.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Actualizar √°ngulo hacia el objetivo
                    bot.angle = Math.atan2(dy, dx);
                    
                    // Ejecutar comportamiento seg√∫n IA y modo t√°ctico
                    this.executeBotBehavior(bot, target, distance);
                    
                    // Disparar con precisi√≥n mejorada
                    this.botShoot(bot, target);
                } else {
                    // Sin objetivos, patrullar o buscar
                    this.botPatrol(bot);
                }
                
                // Actualizar estados especiales
                this.updateBotStates(bot);
            }
            
            evaluateTacticalSituation(bot) {
                const healthRatio = bot.health / bot.maxHealth;
                const nearbyEnemies = this.getNearbyEnemies(bot, 150);
                const nearbyAllies = this.getNearbyAllies(bot, 200);
                
                // Cambiar modo t√°ctico seg√∫n situaci√≥n
                if (healthRatio < bot.healthThreshold && nearbyEnemies.length > 2) {
                    bot.tacticalMode = 'retreat';
                } else if (nearbyAllies.length >= 2 && nearbyEnemies.length > 0) {
                    bot.tacticalMode = 'flanking';
                } else if (healthRatio > 0.8 && nearbyEnemies.length === 1) {
                    bot.tacticalMode = 'charge';
                } else {
                    bot.tacticalMode = 'normal';
                }
            }
            
            findBestTarget(bot) {
                let bestTarget = null;
                let bestScore = -Infinity;
                
                this.enemies.forEach(enemy => {
                    const dx = enemy.x - bot.x;
                    const dy = enemy.y - bot.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Calcular puntuaci√≥n del objetivo
                    let score = 1000 - distance; // M√°s cerca = mejor
                    
                    // Bonus por enemigos d√©biles
                    if (enemy.health < enemy.maxHealth * 0.5) {
                        score += 200;
                    }
                    
                    // Bonus por enemigos que amenazan aliados
                    const nearbyAllies = this.getNearbyAllies(bot, 150);
                    nearbyAllies.forEach(ally => {
                        const allyToEnemyDist = this.getDistance(enemy, ally);
                        if (allyToEnemyDist < 100) {
                            score += 300;
                        }
                    });
                    
                    // Penalizaci√≥n por enemigos muy lejos
                    if (distance > 400) {
                        score -= 500;
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestTarget = enemy;
                    }
                });
                
                return bestTarget;
            }
            
            executeBotBehavior(bot, target, distance) {
                const dx = target.x - bot.x;
                const dy = target.y - bot.y;
                
                switch(bot.tacticalMode) {
                    case 'retreat':
                        this.botRetreat(bot, target);
                        break;
                    case 'flanking':
                        this.botFlank(bot, target);
                        break;
                    case 'charge':
                        this.botCharge(bot, target, distance);
                        break;
                    default:
                        this.botNormalCombat(bot, target, distance);
                        break;
                }
            }
            
            botNormalCombat(bot, target, distance) {
                const dx = target.x - bot.x;
                const dy = target.y - bot.y;
                
                // Mantener distancia preferida
                if (distance > bot.preferredDistance + 50) {
                    // Acercarse
                    bot.x += (dx / distance) * bot.speed * 0.8;
                    bot.y += (dy / distance) * bot.speed * 0.8;
                } else if (distance < bot.preferredDistance - 30) {
                    // Alejarse
                    bot.x -= (dx / distance) * bot.speed * 0.6;
                    bot.y -= (dy / distance) * bot.speed * 0.6;
                }
                
                // Esquivar proyectiles enemigos
                this.botDodge(bot);
            }
            
            botRetreat(bot, target) {
                const dx = target.x - bot.x;
                const dy = target.y - bot.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Alejarse del enemigo
                bot.x -= (dx / distance) * bot.speed * 1.2;
                bot.y -= (dy / distance) * bot.speed * 1.2;
                
                // Buscar aliados para protecci√≥n
                const nearbyAllies = this.getNearbyAllies(bot, 300);
                if (nearbyAllies.length > 0) {
                    const closestAlly = nearbyAllies[0];
                    const allyDx = closestAlly.x - bot.x;
                    const allyDy = closestAlly.y - bot.y;
                    const allyDistance = Math.sqrt(allyDx * allyDx + allyDy * allyDy);
                    
                    if (allyDistance > 50) {
                        bot.x += (allyDx / allyDistance) * bot.speed * 0.5;
                        bot.y += (allyDy / allyDistance) * bot.speed * 0.5;
                    }
                }
            }
            
            botFlank(bot, target) {
                // Calcular posici√≥n de flanqueo
                const dx = target.x - bot.x;
                const dy = target.y - bot.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Movimiento perpendicular al objetivo
                const perpendicularX = -dy / distance;
                const perpendicularY = dx / distance;
                
                bot.x += perpendicularX * bot.speed * 0.7;
                bot.y += perpendicularY * bot.speed * 0.7;
                
                // Mantener distancia de ataque
                if (distance > bot.preferredDistance) {
                    bot.x += (dx / distance) * bot.speed * 0.3;
                    bot.y += (dy / distance) * bot.speed * 0.3;
                }
            }
            
            botCharge(bot, target, distance) {
                const dx = target.x - bot.x;
                const dy = target.y - bot.y;
                
                // Carga directa hacia el objetivo
                bot.x += (dx / distance) * bot.speed * 1.5;
                bot.y += (dy / distance) * bot.speed * 1.5;
                
                // Activar modo de carga si est√° cerca
                if (distance < 80 && Date.now() - bot.lastCharge > bot.chargeCooldown) {
                    bot.isCharging = true;
                    bot.lastCharge = Date.now();
                    bot.chargeCooldown = 5000 + Math.random() * 3000;
                }
            }
            
            botPatrol(bot) {
                // Patrulla cuando no hay objetivos
                if (Date.now() - bot.lastDirectionChange > bot.directionChangeInterval) {
                    bot.lastDirectionChange = Date.now();
                    bot.patrolDirection = Math.random() * Math.PI * 2;
                    bot.directionChangeInterval = 2000 + Math.random() * 3000;
                }
                
                if (bot.patrolDirection !== undefined) {
                    bot.x += Math.cos(bot.patrolDirection) * bot.speed * 0.3;
                    bot.y += Math.sin(bot.patrolDirection) * bot.speed * 0.3;
                }
                
                // Mantener dentro del canvas
                bot.x = Math.max(0, Math.min(this.canvas.width - bot.width, bot.x));
                bot.y = Math.max(0, Math.min(this.canvas.height - bot.height, bot.y));
            }
            
            botDodge(bot) {
                if (Date.now() - bot.lastDodge > bot.dodgeCooldown) {
                    // Buscar proyectiles cercanos
                    const nearbyBullets = this.enemyBullets.filter(bullet => {
                        const dx = bullet.x - bot.x;
                        const dy = bullet.y - bot.y;
                        return Math.sqrt(dx * dx + dy * dy) < 60;
                    });
                    
                    if (nearbyBullets.length > 0) {
                        bot.isDodging = true;
                        bot.lastDodge = Date.now();
                        bot.dodgeCooldown = 1000 + Math.random() * 2000;
                        
                        // Movimiento de esquiva
                        const dodgeDirection = Math.random() * Math.PI * 2;
                        bot.x += Math.cos(dodgeDirection) * bot.speed * 1.5;
                        bot.y += Math.sin(dodgeDirection) * bot.speed * 1.5;
                    }
                }
            }
            
            botShoot(bot, target) {
                if (Date.now() - bot.lastShot > bot.fireRate) {
                    // Calcular precisi√≥n mejorada
                    const accuracy = 0.8 + bot.accuracyBonus;
                    const randomOffset = (1 - accuracy) * (Math.random() - 0.5) * 0.3;
                    
                    // Aplicar offset aleatorio a la precisi√≥n
                    const adjustedAngle = bot.angle + randomOffset;
                    
                    const bullet = {
                        x: bot.x + bot.width / 2 - 2,
                        y: bot.y + bot.height / 2 - 2,
                        width: 4,
                        height: 4,
                        speed: 8 + bot.speedBonus * 0.2,
                        angle: adjustedAngle,
                        damage: bot.damage,
                        isPlayerBullet: true,
                        playerColor: bot.color,
                        isBotBullet: true
                    };
                    
                    this.bullets.push(bullet);
                    bot.lastShot = Date.now();
                }
            }
            
            updateBotStates(bot) {
                // Actualizar estado de esquiva
                if (bot.isDodging && Date.now() - bot.lastDodge > 500) {
                    bot.isDodging = false;
                }
                
                // Actualizar estado de carga
                if (bot.isCharging && Date.now() - bot.lastCharge > 1000) {
                    bot.isCharging = false;
                }
                
                // Regeneraci√≥n de vida para IA avanzada
                if (bot.aiLevel >= 2 && bot.health < bot.maxHealth) {
                    const regenRate = bot.aiLevel === 3 ? 0.5 : 0.2;
                    bot.health = Math.min(bot.maxHealth, bot.health + regenRate);
                }
                
                // Mejora de precisi√≥n con el tiempo para IA avanzada
                if (bot.aiLevel >= 2 && Date.now() - bot.lastShot > 2000) {
                    bot.accuracyBonus = Math.min(0.5, bot.accuracyBonus + 0.01);
                }
            }
            
            getNearbyEnemies(bot, radius) {
                return this.enemies.filter(enemy => {
                    const distance = this.getDistance(bot, enemy);
                    return distance < radius;
                }).sort((a, b) => this.getDistance(bot, a) - this.getDistance(bot, b));
            }
            
            getNearbyAllies(bot, radius) {
                const allAllies = [...this.players, ...this.bots].filter(ally => ally.id !== bot.id);
                return allAllies.filter(ally => {
                    const distance = this.getDistance(bot, ally);
                    return distance < radius;
                }).sort((a, b) => this.getDistance(bot, a) - this.getDistance(bot, b));
            }
            
            getDistance(obj1, obj2) {
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            shoot(shooter) {
                const bullet = {
                    x: shooter.x + shooter.width / 2 - 2,
                    y: shooter.y + shooter.height / 2 - 2,
                    width: 4,
                    height: 4,
                    speed: 8,
                    angle: shooter.angle,
                    damage: shooter.damage,
                    isPlayerBullet: true,
                    playerColor: shooter.color
                };
                this.bullets.push(bullet);
            }
            
            updateEnemies() {
                this.enemies.forEach((enemy, index) => {
                    let target = this.players[0]; // Target principal
                    let nearestDistance = this.getDistance(enemy, this.players[0]);
                    
                    // Buscar el objetivo m√°s cercano entre jugadores y bots
                    [...this.players, ...this.bots].forEach(player => {
                        const distance = this.getDistance(enemy, player);
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            target = player;
                        }
                    });
                    
                    const dx = target.x - enemy.x;
                    const dy = target.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        enemy.x += (dx / distance) * enemy.speed;
                        enemy.y += (dy / distance) * enemy.speed;
                        enemy.angle = Math.atan2(dy, dx);
                    }
                    
                    if (Date.now() - enemy.lastShot > enemy.fireRate) {
                        this.enemyShoot(enemy);
                        enemy.lastShot = Date.now();
                    }
                    
                    // Check collision with all players and bots
                    [...this.players, ...this.bots].forEach((player, playerIndex) => {
                        if (this.checkCollision(enemy, player)) {
                            player.health -= enemy.damage;
                            this.enemies.splice(index, 1);
                            this.addDamageParticles(player, '#ff0000');
                            
                            if (player.health <= 0) {
                                if (player.isLocalPlayer) {
                                    alert(`Game Over! Puntuaci√≥n: ${this.score}`);
                                    window.location.href = 'dungeon.html';
                                } else {
                                    if (player.isBot) {
                                        this.bots.splice(playerIndex, 1);
                                    } else {
                                        const playerArrayIndex = this.players.findIndex(p => p.id === player.id);
                                        this.players.splice(playerArrayIndex, 1);
                                    }
                                }
                            }
                        }
                    });
                });
                
                if (this.enemies.length < 8 && this.enemiesRemaining > 0) {
                    this.spawnEnemies();
                }
            }
            
            enemyShoot(enemy) {
                const dx = this.players[0].x - enemy.x;
                const dy = this.players[0].y - enemy.y;
                const angle = Math.atan2(dy, dx);
                
                const bullet = {
                    x: enemy.x + enemy.width / 2 - 2,
                    y: enemy.y + enemy.height / 2 - 2,
                    width: 4,
                    height: 4,
                    speed: 4,
                    angle: angle,
                    damage: enemy.damage
                };
                this.enemyBullets.push(bullet);
            }
            
            updateBullets() {
                this.bullets.forEach((bullet, bulletIndex) => {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed;
                    
                    this.enemies.forEach((enemy, enemyIndex) => {
                        if (this.checkCollision(bullet, enemy)) {
                            enemy.health -= bullet.damage;
                            this.bullets.splice(bulletIndex, 1);
                            this.addDamageParticles(enemy, '#888888');
                            
                            if (enemy.health <= 0) {
                                this.enemies.splice(enemyIndex, 1);
                                this.enemiesKilled++;
                                this.enemiesRemaining--;
                                this.score += 100;
                                this.exp += 10;
                                
                                this.coins.push({
                                    x: enemy.x + enemy.width / 2,
                                    y: enemy.y + enemy.height / 2,
                                    value: 10,
                                    life: 300
                                });
                                
                                if (this.enemiesRemaining <= 0) {
                                    this.completeWave();
                                }
                            }
                        }
                    });
                    
                    if (bullet.x < 0 || bullet.x > this.canvas.width || 
                        bullet.y < 0 || bullet.y > this.canvas.height) {
                        this.bullets.splice(bulletIndex, 1);
                    }
                });
                
                this.enemyBullets.forEach((bullet, bulletIndex) => {
                    bullet.x += Math.cos(bullet.angle) * bullet.speed;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed;
                    
                    [...this.players, ...this.bots].forEach(player => {
                        if (this.checkCollision(bullet, player)) {
                            player.health -= bullet.damage;
                            this.enemyBullets.splice(bulletIndex, 1);
                            this.addDamageParticles(player, '#ff0000');
                        }
                    });
                    
                    if (bullet.x < 0 || bullet.x > this.canvas.width || 
                        bullet.y < 0 || bullet.y > this.canvas.height) {
                        this.enemyBullets.splice(bulletIndex, 1);
                    }
                });
            }
            
            updateCoins() {
                this.coins.forEach((coin, index) => {
                    const dx = this.players[0].x - coin.x;
                    const dy = this.players[0].y - coin.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 100) {
                        coin.x += (dx / distance) * 3;
                        coin.y += (dy / distance) * 3;
                    }
                    
                    if (this.checkCollision(coin, this.players[0])) {
                        this.coins += coin.value;
                        this.coins.splice(index, 1);
                    }
                    
                    coin.life--;
                    if (coin.life <= 0) {
                        this.coins.splice(index, 1);
                    }
                });
            }
            
            updateParticles() {
                this.particles.forEach((particle, index) => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(index, 1);
                    }
                });
            }
            
            addDamageParticles(target, color) {
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: target.x + target.width / 2,
                        y: target.y + target.height / 2,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 20,
                        color: color
                    });
                }
            }
            
            completeWave() {
                this.currentWave++;
                
                if (this.currentWave > this.maxWaves) {
                    alert(`¬°Felicidades! Has completado Mercurio en ${this.formatTime(Date.now() - this.gameStartTime)}`);
                    window.location.href = 'dungeon.html';
                    return;
                }
                
                setTimeout(() => {
                    this.startWave();
                }, 2000);
            }
            
            getDistance(obj1, obj2) {
                const dx = obj2.x - obj1.x;
                const dy = obj2.y - obj1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
            
            formatTime(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
            }
            
            updateUI() {
                const localPlayer = this.players.find(p => p.isLocalPlayer);
                if (localPlayer) {
                    document.getElementById('planet-level').textContent = this.level;
                    document.getElementById('planet-hp').textContent = `${localPlayer.health}/${localPlayer.maxHealth}`;
                    document.getElementById('planet-exp').textContent = `${this.exp}/${this.expToNext}`;
                    document.getElementById('planet-score').textContent = this.score;
                    document.getElementById('planet-coins').textContent = this.coins;
                    document.getElementById('planet-enemies').textContent = this.enemies.length;
                    document.getElementById('current-wave').textContent = this.currentWave;
                    document.getElementById('enemies-remaining').textContent = this.enemiesRemaining;
                    document.getElementById('planet-time').textContent = this.formatTime(Date.now() - this.gameStartTime);
                    document.getElementById('player-id').textContent = localPlayer.id;
                }
                
                this.updatePlayerCounts();
                
                const progress = (this.enemiesKilled / this.enemiesInWave) * 100;
                document.getElementById('waveProgressFill').style.width = `${progress}%`;
            }
            
            render() {
                this.ctx.fillStyle = '#666666';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawPlayers();
                this.drawBots();
                this.enemies.forEach(enemy => this.drawEnemy(enemy));
                this.bullets.forEach(bullet => this.drawBullet(bullet));
                this.enemyBullets.forEach(bullet => this.drawEnemyBullet(bullet));
                this.coins.forEach(coin => this.drawCoin(coin));
                this.particles.forEach(particle => this.drawParticle(particle));
            }
            
            drawPlayers() {
                this.players.forEach(player => {
                    this.ctx.save();
                    this.ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
                    this.ctx.rotate(player.angle);
                    
                    // Todos los jugadores se ven igual (simulados y reales)
                    this.ctx.fillStyle = player.color;
                    this.ctx.beginPath();
                    this.ctx.moveTo(15, 0);
                    this.ctx.lineTo(-10, -8);
                    this.ctx.lineTo(-5, 0);
                    this.ctx.lineTo(-10, 8);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                    
                    // Draw player name (sin indicadores especiales)
                    this.ctx.fillStyle = player.color;
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(player.name, player.x + player.width / 2, player.y - 10);
                    
                    // Barra de vida para todos los jugadores
                    this.drawPlayerHealthBar(player);
                });
            }
            
            drawPlayerHealthBar(player) {
                const barWidth = 30;
                const barHeight = 4;
                const barX = player.x + player.width / 2 - barWidth / 2;
                const barY = player.y + player.height + 5;
                
                // Fondo de la barra
                this.ctx.fillStyle = '#333333';
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // Vida actual
                const healthRatio = player.health / player.maxHealth;
                const healthWidth = barWidth * healthRatio;
                
                let healthColor = '#00ff00';
                if (healthRatio < 0.5) healthColor = '#ffff00';
                if (healthRatio < 0.25) healthColor = '#ff0000';
                
                this.ctx.fillStyle = healthColor;
                this.ctx.fillRect(barX, barY, healthWidth, barHeight);
                
                // Borde de la barra
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(barX, barY, barWidth, barHeight);
            }
            
            drawBots() {
                this.bots.forEach(bot => {
                    this.ctx.save();
                    this.ctx.translate(bot.x + bot.width / 2, bot.y + bot.height / 2);
                    this.ctx.rotate(bot.angle);
                    
                    // Color base del bot
                    this.ctx.fillStyle = bot.color;
                    this.ctx.fillRect(-bot.width / 2, -bot.height / 2, bot.width, bot.height);
                    
                    // Borde seg√∫n nivel de IA
                    let borderColor = '#ffffff';
                    let borderWidth = 1;
                    
                    if (bot.aiLevel === 2) {
                        borderColor = '#00ff00';
                        borderWidth = 2;
                    } else if (bot.aiLevel === 3) {
                        borderColor = '#ff00ff';
                        borderWidth = 3;
                    }
                    
                    this.ctx.strokeStyle = borderColor;
                    this.ctx.lineWidth = borderWidth;
                    this.ctx.strokeRect(-bot.width / 2, -bot.height / 2, bot.width, bot.height);
                    
                    // Efectos especiales seg√∫n estado
                    if (bot.isDodging) {
                        this.ctx.strokeStyle = '#ffff00';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(-bot.width / 2 - 5, -bot.height / 2 - 5, bot.width + 10, bot.height + 10);
                    }
                    
                    if (bot.isCharging) {
                        this.ctx.strokeStyle = '#ff0000';
                        this.ctx.lineWidth = 3;
                        this.ctx.strokeRect(-bot.width / 2 - 8, -bot.height / 2 - 8, bot.width + 16, bot.height + 16);
                    }
                    
                    this.ctx.restore();
                    
                    // Nombre del bot
                    this.ctx.fillStyle = bot.color;
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(bot.name, bot.x + bot.width / 2, bot.y - 10);
                    
                    // Indicadores de IA
                    this.drawBotIndicators(bot);
                });
            }
            
            drawBotIndicators(bot) {
                const indicatorY = bot.y - 25;
                
                // Nivel de IA
                let aiText = '';
                let aiColor = '#ffffff';
                
                switch(bot.aiLevel) {
                    case 1:
                        aiText = 'IA';
                        aiColor = '#ffffff';
                        break;
                    case 2:
                        aiText = 'IA+';
                        aiColor = '#00ff00';
                        break;
                    case 3:
                        aiText = 'IA++';
                        aiColor = '#ff00ff';
                        break;
                }
                
                this.ctx.fillStyle = aiColor;
                this.ctx.font = '10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(aiText, bot.x + bot.width / 2, indicatorY);
                
                // Modo t√°ctico
                const modeY = bot.y - 40;
                let modeText = '';
                let modeColor = '#ffffff';
                
                switch(bot.tacticalMode) {
                    case 'normal':
                        modeText = '‚öîÔ∏è';
                        modeColor = '#ffffff';
                        break;
                    case 'retreat':
                        modeText = 'üõ°Ô∏è';
                        modeColor = '#00ffff';
                        break;
                    case 'flanking':
                        modeText = '‚ö°';
                        modeColor = '#ffff00';
                        break;
                    case 'charge':
                        modeText = 'üî•';
                        modeColor = '#ff0000';
                        break;
                }
                
                this.ctx.fillStyle = modeColor;
                this.ctx.font = '14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(modeText, bot.x + bot.width / 2, modeY);
                
                // Barra de vida con bonificaciones
                this.drawBotHealthBar(bot);
            }
            
            drawBotHealthBar(bot) {
                const barWidth = 30;
                const barHeight = 4;
                const barX = bot.x + bot.width / 2 - barWidth / 2;
                const barY = bot.y + bot.height + 5;
                
                // Fondo de la barra
                this.ctx.fillStyle = '#333333';
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // Vida actual
                const healthRatio = bot.health / bot.maxHealth;
                const healthWidth = barWidth * healthRatio;
                
                let healthColor = '#00ff00';
                if (healthRatio < 0.5) healthColor = '#ffff00';
                if (healthRatio < 0.25) healthColor = '#ff0000';
                
                this.ctx.fillStyle = healthColor;
                this.ctx.fillRect(barX, barY, healthWidth, barHeight);
                
                // Borde de la barra
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // Indicador de bonificaciones
                if (bot.attackBonus > 0 || bot.defenseBonus > 0) {
                    const bonusY = barY + barHeight + 8;
                    let bonusText = '';
                    
                    if (bot.attackBonus > 0) {
                        bonusText += `‚öîÔ∏è+${bot.attackBonus}`;
                    }
                    if (bot.defenseBonus > 0) {
                        bonusText += `üõ°Ô∏è+${bot.defenseBonus}`;
                    }
                    
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.font = '8px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(bonusText, bot.x + bot.width / 2, bonusY);
                }
            }
            
            drawEnemy(enemy) {
                this.ctx.fillStyle = enemy.color;
                this.ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(enemy.x, enemy.y, enemy.width, enemy.height);
            }
            
            drawBullet(bullet) {
                if (bullet.isBotBullet) {
                    // Balas de bots con efectos especiales
                    this.ctx.save();
                    
                    // Efecto de brillo para balas de IA avanzada
                    this.ctx.shadowColor = bullet.playerColor;
                    this.ctx.shadowBlur = 5;
                    
                    this.ctx.fillStyle = bullet.playerColor;
                    this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    
                    // Efecto de trazo para balas de bots
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    
                    this.ctx.restore();
                } else {
                    // Balas normales de jugador (simulados y reales se ven igual)
                    this.ctx.fillStyle = bullet.playerColor || '#00ffff';
                    this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                }
            }
            
            drawEnemyBullet(bullet) {
                this.ctx.fillStyle = '#888888';
                this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            }
            
            drawCoin(coin) {
                this.ctx.fillStyle = '#ffff00';
                this.ctx.beginPath();
                this.ctx.arc(coin.x, coin.y, 5, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.strokeStyle = '#ffaa00';
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
            }
            
            drawParticle(particle) {
                this.ctx.fillStyle = particle.color;
                this.ctx.globalAlpha = particle.life / 20;
                this.ctx.fillRect(particle.x, particle.y, 3, 3);
                this.ctx.globalAlpha = 1;
            }
            
            update() {
                if (this.gameState === 'playing') {
                    this.updatePlayers();
                    this.updateBots();
                    this.updateEnemies();
                    this.updateBullets();
                    this.updateCoins();
                    this.updateParticles();
                    this.updateUI();
                }
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        window.addEventListener('load', () => {
            new MercuryDungeon();
        });
    </script>
</body>
</html> 